require 'spec_helper'

RegexForAuthFailShow = /can not view the requested/
RegexForAuthFailNew = /can not create the requested/
RegexForAuthFailModify = /can not update the requested/
RegexForAuthFailEdit = /can not edit the requested/
RegexForAuthFailDestroy = /can not destroy the requested/
RegexDeleteSuccess = /(.*) was deleted/


# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe Admin::ProjectsController do
  before(:each) do
    # not required, but prevents warning messages in console when running specs:
    generate_default_settings_with_mocks
  end
  let(:project) { FactoryBot.create(:project, landing_page_slug: 'foo-proj', landing_page_content: '<h1>Foo</h1>') }
  let(:valid_attributes) { { name: "Some name" } }

  describe 'when user is an admin' do
    before(:each) do
      login_admin
    end

    describe "#index" do
      it "assigns all projects as @projects" do
        project
        get :index
        expect(assigns(:projects).to_a).to eq([project])
      end
    end

    describe "#show" do
      it "assigns the requested project as @project" do
        get :show, params: { :id => project.to_param }
        expect(assigns(:project)).to eq(project)
      end
    end

    describe "#new" do
      it "assigns a new project as @project" do
        get :new
        expect(assigns(:project)).to be_a_new(Admin::Project)
      end
    end

    describe "#edit" do
      it "assigns the requested project as @project" do
        get :edit, params: { :id => project.to_param }
        expect(assigns(:project)).to eq(project)
      end
    end

    describe "#create" do
      describe "with valid params" do
        it "creates a new Admin::Project" do
          expect {
            post :create, params: { :admin_project => valid_attributes }
          }.to change(Admin::Project, :count).by(1)
        end

        it "assigns a newly created project as @project" do
          post :create, params: { :admin_project => valid_attributes }
          expect(assigns(:project)).to be_a(Admin::Project)
          expect(assigns(:project)).to be_persisted
        end

        it "redirects to the projects index" do
          post :create, params: { :admin_project => valid_attributes }
          expect(response).to redirect_to(admin_projects_url)
        end
      end

      describe "with invalid params" do
        it "assigns a newly created but unsaved project as @project" do
          # Trigger the behavior that occurs when invalid params are submitted
          allow_any_instance_of(Admin::Project).to receive(:save).and_return(false)
          post :create, params: { :admin_project => valid_attributes }
          expect(assigns(:project)).to be_a(Admin::Project)
          expect(assigns(:project)).not_to be_persisted
          expect(assigns(:project)).to be_a_new(Admin::Project)
        end

        it "re-renders the 'new' template" do
          # Trigger the behavior that occurs when invalid params are submitted
          allow_any_instance_of(Admin::Project).to receive(:save).and_return(false)
          post :create, params: { :admin_project => valid_attributes }
          expect(response).to render_template(:new)
        end
      end
    end

    describe "PUT update" do
      describe "with valid params" do
        it "updates the requested project" do
          # Assuming there are no other projects in the database, this
          # specifies that the Admin::Project created on the previous line
          # receives the :update message with whatever params are
          # submitted in the request.
          expect_any_instance_of(Admin::Project).to receive(:update).with(permit_params!({'name' => 'new name'}))
          put :update, params: { :id => project.to_param, :admin_project => {'name' => 'new name'} }
        end

        it "assigns the requested project as @project" do
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(assigns(:project)).to eq(project)
        end

        it "redirects to the project" do
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(response).to redirect_to(project)
        end
      end

      describe "with invalid params" do
        it "assigns the project as @project" do
          # Trigger the behavior that occurs when invalid params are submitted
          allow_any_instance_of(Admin::Project).to receive(:save).and_return(false)
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(assigns(:project)).to eq(project)
        end

        it "re-renders the 'edit' template" do
          # Trigger the behavior that occurs when invalid params are submitted
          allow_any_instance_of(Admin::Project).to receive(:save).and_return(false)
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(response).to render_template("edit")
        end
      end
    end

    describe "DELETE destroy" do
      it "destroys the requested project" do
        project
        expect {
          delete :destroy, params: { :id => project.to_param }
        }.to change(Admin::Project, :count).by(-1)
      end

      it "redirects to the projects list" do
        delete :destroy, params: { :id => project.to_param }
        expect(response).to redirect_to(admin_projects_url)
      end
    end
  end

  describe 'when user is a project admin' do
    let(:user) { FactoryBot.create(:user) }
    let(:project_1) { FactoryBot.create(:project, name: 'project_1') }
    let(:project_2) { FactoryBot.create(:project, name: 'project_2') }
    let(:project_3) { FactoryBot.create(:project, name: 'project_3') }
    let(:users_projects) { [project, project_1] }
    let(:other_projects)  { [project_2, project_3] }

    before(:each) do
      users_projects.each do |proj|
        user.add_role_for_project('admin', proj)
      end
      allow(controller).to receive(:current_user).and_return(user)
    end

    describe "#index" do
      it "Only lists projects for which the user is a project admin" do
        get :index
        expect(assigns(:projects).to_a).to eq(users_projects)
      end
    end

    describe "#show" do
      context 'the users projects' do
        it "assigns the requested project as @project" do
          users_projects.each do |proj|
            get :show, params: { id: proj.id }
            expect(assigns(:project)).to eq(proj)
          end
        end
      end

      context 'other projects' do
        it "It will also show those" do
          other_projects.each do |proj|
            get :show, params: { id:  proj.id }
            expect(assigns(:project)).to eq(proj)
          end
        end
      end
    end

    describe "#new" do
      it "is unavailable to project admins" do
        get :new
        expect(response).to have_http_status(:redirect)
        expect(request.flash['alert']).to match(RegexForAuthFailNew)
      end
    end

    describe "#edit" do
      context "their own projects" do
        it "assigns the requested project as @project" do
          users_projects.each do |proj|
            get :edit, params: { id: proj.id }
            expect(assigns(:project)).to eq(proj)
          end
        end
      end

      context "other projects" do
        it "it won't let them edit" do
          other_projects.each do |proj|
            get :edit, params: { id: proj.id }
            expect(response).to have_http_status(:redirect)
            expect(request.flash['alert']).to match(RegexForAuthFailEdit)
          end
        end
      end
    end

    describe "#create" do
      describe "with valid params" do
        it "wont let them" do
          expect {
            post :create, params: { :admin_project => valid_attributes }
          }.not_to change(Admin::Project, :count)
        end

        it "redirects with warning" do
          post :create, params: { :admin_project => valid_attributes }
          expect(response).to have_http_status(:redirect)
          expect(request.flash['alert']).to match(RegexForAuthFailNew)
        end
      end
    end

    describe "PUT update" do
      context "their own project" do
        let(:project) { project_1 }
        it "updates the requested project" do
          # Assuming there are no other projects in the database, this
          # specifies that the Admin::Project created on the previous line
          # receives the :update message with whatever params are
          # submitted in the request.
          expect_any_instance_of(Admin::Project).to receive(:update).with(permit_params!({'name' => 'new name'}))
          put :update, params: { :id => project.id, :admin_project => {'name' => 'new name'} }
        end

        it "assigns the requested project as @project" do
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(assigns(:project)).to eq(project)
        end

        it "redirects to the project" do
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(response).to redirect_to(project)
        end
      end
      describe "with invalid params" do
        it "assigns the project as @project" do
          # Trigger the behavior that occurs when invalid params are submitted
          allow_any_instance_of(Admin::Project).to receive(:save).and_return(false)
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(assigns(:project)).to eq(project)
        end

        it "re-renders the 'edit' template" do
          # Trigger the behavior that occurs when invalid params are submitted
          allow_any_instance_of(Admin::Project).to receive(:save).and_return(false)
          put :update, params: { :id => project.to_param, :admin_project => valid_attributes }
          expect(response).to render_template("edit")
        end
      end
    end

    describe "DELETE destroy" do
      context "their own project" do
        let(:project) { project_1 }
        it "wont destroy the project" do
          project
          expect {
            delete :destroy, params: { :id => project.id }
          }.not_to change(Admin::Project, :count)
        end

        it "redirects to the projects list" do
          delete :destroy, params: { :id => project.id }
          expect(response).to have_http_status(:redirect)
          expect(request.flash['alert']).to match(RegexForAuthFailDestroy)
        end
      end
    end
  end

  describe 'when user is not logged in' do
    describe "#index" do
      it "redirects to the login page" do
        project
        get :index
        expect(response).to have_http_status(:redirect)
        expect(response.location).to include(auth_login_path)
      end
    end
  end

  describe "#landing page" do
    context "there is a project matching the slug" do
      it "renders landing page template" do
        get :landing_page, params: { :landing_page_slug => project.landing_page_slug }
        expect(response).to render_template("landing_page")
      end

      context "when the current user is a student" do
        let (:student_user) {
          student = FactoryBot.create(:full_portal_student)
          student.user
        }
        before(:each) do
          sign_in student_user
        end

        # NOTE: this is going to traverse through pundit to
        # ApplicationController#pundit_user_not_authorized
        # which will in turn call back to 'humanize_action', and not_authorized_error_message
        it "does not allow access, the student is redirected to their home page" do
          get :landing_page, params: { :landing_page_slug => project.landing_page_slug }
          expect(response).to redirect_to(controller.send(:after_sign_in_path_for, student_user))
        end
      end
    end

    context "there is no project matching the slug" do
      it "renders 404" do
        get :landing_page, params: { :landing_page_slug => "some-slug-which-doesnt-exist" }
        expect(response.status).to eq(404)
      end
    end
  end
end
